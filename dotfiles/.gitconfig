[core]
  excludesfile = ~/.gitignore
  pager = less -F -X
  mergeoptions = --no-edit

[color]
  ui = auto # Use colors in Git commands that are capable of colored output when outputting to the terminal

[color "branch"]
  current = yellow reverse
  local = yellow
  remote = green


[color "diff"]
  meta = yellow bold
  frag = magenta bold
  old = red bold
  new = green bold


[color "status"]
  added = yellow
  changed = green
  untracked = cyan

# Use `origin` as the default remote on the `master` branch in all cases
[branch "master"]
  remote = origin
  merge = refs/heads/master

[merge]
  log = true

[mergetool]
  keepBackup = true

[apply]
  ignorewhitespace = change
  whitespace = nowarn

[push]
  # default = matching
  default = upstream
  rebase = true

[credential]
  helper = osxkeychain

[user]
  email = tjbenton21@gmail.com
  name = Tyler Benton

[filter "media"]
  clean = git-media-clean %f
  smudge = git-media-smudge %f

[alias]
  root = rev-parse --show-toplevel #cdroot = !cd `git root`

  upstream = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)
  upstream-remote = !git upstream | sed -e 's/\\/.*$//g'

  out = !git fetch `git upstream-remote` && git l `git upstream`..HEAD
  in = pull --dry-run

  # checkout
  go = checkout -B # Switch to a branch, creating it if necessary
  goc = checkout .
  gob = checkout -b
  gobf = "!f() { git brd $1; git gob $1; }; f"
  gol = checkout HEAD~1
  gotc = !git sttc | xargs git checkout
  gomo = !git stmo | xargs git checkout
  ours = checkout --ours
  aours = "!f() { (git reset $* >/dev/null); git ours $* && git add $*; }; f"
  theirs = checkout --theirs
  atheirs = "!f() { (git reset $* >/dev/null); git theirs $* && git add $*; }; f"

  # commit
  co = commit
  coa = !git add -A && git commit -av # Commit all changes
  coe = commit --allow-empty
  coam = commit --amend
  coama = commit --amend -a

  # clean
  cl = clean
  cldf = clean -df

  # reset
  res = reset
  resa = reset HEAD
  resh = "!f() { git stash && git reset --hard $@; }; f"
  reshu = !git resh `git upstream`
  reshfu = !git fetch `git upstream-remote` && git resh `git upstream`
  reshh = !git stash && git reset --hard HEAD
  cundo = reset HEAD^1
  cundoh = !git stash && git reset HEAD^1 --hard
  unstage = reset HEAD

  # Clone a repository including all submodules
  c = clone --recursive

  # tags
  t = for-each-ref --sort=-taggerdate --format='%(refname:short)' refs/tags # Tags sorted by date
  tags = tag -l # Show verbose output about tags, branches or remotes

  # show
  s = show --color
  sw = show --color --color-words='[^[:space:]]|([[:alnum:]]|UTF_8_GUARD)+'
  sf = show --color --name-only

  # status
  st = status -s # View the current working tree status using the short format
  stl = status # View status using the long format
  stv = status # View status using the long format
  sttc = !git status | grep typechange | awk '{print $2}'
  stmo = !git status | grep modified | awk '{print $2}'

  # Diff
  pg = diff
  pgs = diff --staged
  pa = apply
  d = diff --color --patch-with-stat
  dw = diff --color --color-words='[^[:space:]]|([[:alnum:]]|UTF_8_GUARD)+'
  du = !git d `git upstream`
  ds = !git d --staged
  dsw = !git d --staged --color-words='[^[:space:]]|([[:alnum:]]|UTF_8_GUARD)+'
  dsf = !git d --staged --name-only
  df = !git d --name-only
  dc = "!f() { HASH=$1; shift 1; git diff --cc $HASH $HASH^1 $HASH^2 $@; }; f"

  # log
  # Log with more info
  lg = log --color --graph -n 20 --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --
  lp = log -m --no-merges --color -p
  lf = log -m --no-merges --color -p --name-only
  lg = log -m --simplify-merges --color --graph --pretty=format:'%Cred%h%Creset %s %Cgreen(%ar) %Cblue%an <%ae>%Creset' --abbrev-commit --date=relative
  lgu = !git lg `git upstream`
  lg2 = !source ~/.githelpers && pretty_git_log
  lgp = !git lg --no-merges -p
  lgpw = !git lg --no-merges -p --color-words='[^[:space:]]|([[:alnum:]]|UTF_8_GUARD)+'
  lgf = !git lg --no-merges -p --name-only
  l = log -m --simplify-merges --color --pretty=format:'%Cred%h%Creset %s %Cgreen(%cr) %Cblue%an <%ae>%Creset' --abbrev-commit --date=relative
  lc = "!f() { git log $* | grep '^commit ' | cut -f 2 -d ' '; }; f"

  # short log
  sl = shortlog -sne

  # fetch
  f = fetch
  fu = !git fetch `git upstream-remote`
  fa = fetch --all
  fo = fetch origin

  # merge
  m = merge --no-edit
  unm = reset --merge

  # push
  ps = push
  psu = push -u
  psn = "!f() { git ps $1 `git brc`; }; f"
  psnf = "!f() { git psf $1 `git brc`; }; f"
  psun = "!f() { git psu $1 `git brc`; }; f"
  pso = push origin
  psoun = !git psu origin `git brc`
  psf = push -f
  psuf = push -uf
  pssm = push --recurse-submodules=on-demand
  psremoveallbranches = "!f() { git push $1 `git brar $1 | grep -v master | xargs -I {} echo :{}`; }; f"

  # Pull
  p = !"git pull; git submodule foreach git pull origin master" # Pull in remote changes for the current repository and all its submodules
  pl = pull
  plo = pull origin
  plom = pull origin master
  plr = pull --rebase

  # add
  a = add --all
  af = add --all -f
  ap = add -p
  resolve-unmerged = !git add `git unmerged`
  add-untracked = !git add `git untracked`
  as = !git diff -w --no-color | git apply --cached
  rs = !(git resa && git as && git go . && git resa) &>/dev/null

  # rm
  rmf = rm -rf
  rmtheirs = !git rm `git removedbytheirs`
  rmours = !git rm `git removedbyours`

  # merged
  unmerged = !git ls-files --unmerged | cut -f2 | uniq
  # theirsunmerged = !git ls-files --unmerged | grep \"\\\\s3\\\\s\" | cut -f2 | uniq
  # oursunmerged = !git ls-files --unmerged | grep \"\\\\s2\\\\s\" | cut -f2 | uniq
  # removedbyours = !bash -c 'source ~/.githelpers && diff_array \"`git theirsunmerged`\" \"`git oursunmerged`\"'
  # removedbytheirs = !bash -c 'source ~/.githelpers && diff_array \"`git oursunmerged`\" \"`git theirsunmerged`\"'

  # ls-files
  untracked = ls-files --other --exclude-standard
  staged = ls-files --staged
  modified = ls-files --modified
  deleted = ls-files --deleted
  gitignored = ls-files -o -i --exclude-standard
  sig = !git ls-files -v | grep "^[[:lower:]]"

  # update-index
  ig = update-index --assume-unchanged
  uig = update-index --no-assume-unchanged
  ignore = update-index --assume-unchanged
  ignored = !git sig

  gitignore-untracked = !git gitignore `git untracked`
  ig-untracked = !git ignore `git untracked`
  gitignore = !cd `git root` && touch .gitignore

  # head
  head = !git l -1
  h = !git head
  hp = !source ~/.githelpers && show_git_head
  r = !git l -20
  ra = !git r --all

  # stash
  sh = stash
  sha = stash apply
  shl = stash list
  shd = stash drop
  shc = stash clear

  # cherry-pick
  chp = cherry-pick
  chpc = cherry-pick --continue
  chpq = cherry-pick --quit
  chpa = cherry-pick --abort

  # revert
  rv = revert
  rvc = revert --continue
  rva = revert --abort

  # am
  am3 = am -3
  amr = am --resolved
  amc = am --continue
  ama = am --abort
  ams = am --skip

  # format-patch
  fm = format-patch

  # rebase
  rb = rebase
  rbad = rebase --committer-date-is-author-date
  rbi = rebase -i
  rbtc = !git theirs `git unmerged` || git resolve-unmerged && (git rbc || git rbs)
  rboc = !git ours `git unmerged` || git reset `git unmerged` && git a . && (git rbc || git rbs)
  rbc = rebase --continue
  rba = rebase --abort
  rbs = rebase --skip

  # squash
  squash = !"f() { NL=$1; GIT_EDITOR=\"sed -i '2,$NL s/pick/squash/;/# This is the 2nd commit message:/,$ {d}'\"; git rebase -i HEAD~$NL; }; f"
  sq = !git squash $1
  sqpsf = !git squash $1 && git psf

  # bisect
  bs = bisect
  bsr = bisect reset
  bsb = bisect bad
  bsg = bisect good

  # branch
  current = rev-parse --abbrev-ref HEAD
  br = branch
  brc = rev-parse --abbrev-ref HEAD
  brt = branch --track
  brup = branch --set-upstream
  bra = !git branch -a | less -FiRS
  brrecent = !git for-each-ref --sort=-committerdate refs/heads/
  brar = "!f() { git bra | grep remotes/$1/ | cut -f 3 -d '/'; }; f"
  brd = branch -D
  brco = branch --contains
  brcommits = "!f() { git lc --branches=$1* }; f"
  brdiff = !source ~/.githelpers && diff_branches
  brfdiff = !source ~/.githelpers && diff_branches_show_files

  # remote
  rem = remote
  rema = remote add
  remr = remote rm
  remv = remote -v
  remotes = remote -v

  # submodule
  sm = submodule
  smst = submodule --status
  sma = submodule add
  smu = submodule update
  sme = submodule foreach
  smepl = submodule foreach "(git checkout master; git pull)&"
  smui = submodule update --init
  smuir = submodule update --init --recursive
  sms = submodule sync

  # blame
  bl = blame

  # gc
  gcp = gc --prune=now
  gca = gc --aggressive
  gcap = gc --aggressive --prune=now

  # reflog
  rf = reflog
  rfe = reflog expire --expire=now --all

  # prune
  pr = prune
  prm = !git rfe && git gcp

  # file size
  fsize = git ls-tree -r -t -l --full-name HEAD | sort -rn -k 4 | less

  # empty dirs
  findemptydirs = !"find . -type d -empty ! -path ./tmp/\\*"
  deleteemptydirs = !"find . -type d -empty ! -path ./tmp/\\* -exec rmdir {} \\;"

  # fancy helper functions to help change commits
  # git change-commits GIT_AUTHOR_EMAIL "old name" "new name"
  change-commits = "!f() { VAR=$1; OLD=$2; NEW=$3; shift 3; git filter-branch --env-filter \"if [ \\"$echo $VAR\\" = \\"$OLD\\" ]; then export $VAR=\\"$NEW\\"; fi\" $@; }; f" ]
  # from https://help.github.com/articles/remove-sensitive-data
  remove-file = "!f() { git filter-branch -f --index-filter \"git rm --cached --ignore-unmatch $1\" --prune-empty --tag-name-filter cat -- --all; }; f"

  # git change-email "old email" "new email"
  change-email = "!f() { VAR=GIT_AUTHOR_EMAIL; OLD=$2; NEW=$3; shift 3; git filter-branch --env-filter \"if [ \\"$echo $VAR\\" = \\"$OLD\\" ]; then export $VAR=\\"$NEW\\"; fi\" $@; }; f" ]
  # git change-name "old name" "new name"
  change-name = "!f() { VAR=GIT_AUTHOR_NAME; OLD=$2; NEW=$3; shift 3; git filter-branch --env-filter \"if [ \\"$echo $VAR\\" = \\"$OLD\\" ]; then export $VAR=\\"$NEW\\"; fi\" $@; }; f" ]

  # Remove all deleted items from git
  rmd = git rm $(git ls-files --deleted)

  # branches
  branches = branch -a
  remotes = remote -v

  # Credit an author on the latest commit
  credit = "!f() { git commit --amend --author \"$1 <$2>\" -C HEAD; }; f"

  # Undo a `git push`
  undopush = push -f origin HEAD^:master

  # More tag related stuff
  previoustag = !sh -c 'git t --count 2 | cut -f2 | sed -n 2p'
  markdownlog = log --color --pretty=format:'* %s `%Cred%h%Creset` - %C(bold blue)[%an](mailto:%ae)%Creset' --abbrev-commit --dense --no-merges --reverse
  markdownlogtag = !sh -c 'git markdownlog ...`git previoustag`'
  hockeylog = log --pretty=format:'* %s [%an]' --abbrev-commit --dense --no-merges --reverse
  hockeylogtag = !sh -c 'git hockeylog ...`git previoustag`'

  # search for a specific line of code in all commits in the repo.
  # Example: to find when the line "constraint=someMethod," was commented out, use:
  # git search '#constraint=someMethod,'
  search = "!f() { git log -S$1 --pretty=oneline --abbrev-commit; }; f"
[filter "lfs"]
  smudge = git-lfs smudge %f
  required = true
  clean = git-lfs clean %f